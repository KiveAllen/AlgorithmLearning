```java
public class Test01 {

    //递归方法
    public static int Recursion(int n){
        if(n==1)return 1;
        if(n==2)return 2;

        return Recursion(n-1)+Recursion(n-2);
    }
    //递归的次数以一个二叉树的形式增加，容易知道代码的时间复杂度和二叉树的节点个数有关，得到O(2^n)
    //因为递归没有申请额外空间，所以空间复杂度为O(1)

    //递推方法
    public static int Recurrence(int n){
        if(n==1)return 1;
        if(n==2)return 2;

        int Part1 = 1;
        int Part2 = 2;
        int temp;
        int sum = 0;

        for (int i = 3; i <= n; i++) {
            sum = Part1+Part2;
            temp = Part2;
            Part2 = sum;
            Part1 = temp;
        }

        return sum;
    }
    //递推很容易看出，代码执行的次数与n有关，可以得到它的时间复杂度应该为O(n)
    //因为没有开辟多的空间，所以空间复杂度为O(1)


    public static void main(String[] args) {
        System.out.println(Recurrence(4));

        System.out.println(Recursion(20));

    }

}

```

### 运行如下：

![tutu](https://github.com/KiveAllen/AlgorithmLearning/blob/main/%E5%9B%BE%E7%89%87%E5%92%8C%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C/%E9%98%B6%E6%A2%AF%E7%9A%84%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.jpg)
